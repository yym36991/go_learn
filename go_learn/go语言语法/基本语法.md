
基本语法学习
# 1、new和make的区别
<details>
  <summary>查看/隐藏代码</summary>
  入参和出参不同：都是接收类型Type, new只接收一个形参，返回这个类型的指针，make接收类型Type,和其他参数，长度、容量等，返回Type类型，（传指针返回指针，传类型返回类型） 
  使用场景不同：专门用来构造slice,map,chan类型，等引用类型。比如slice包括一个数据结构：返回底层数组的指针， new不能用来构造引用类型，因为会做零值处理，指针做0值，会处理成nil，显然是错误的。
  
</details>

# 2、切片和数组的区别？
<details>
  <summary> 查看/隐藏</summary>
  数组是值类型，切片是包含数组的指针，的引用类型，除了指针还有其他数据长度容量等
  切片会动态扩容，如果A切片有引用B，则引用的B不会随着扩容而变化，但是A变成了新扩容的新地址
</details>

# 3、for range 底层地址发生改变吗？
<details>
  <summary> 查看/隐藏</summary>
  不会，这个遍历是值遍历，每次都新创建当前元素的副本，新建元素副本的地址会变化，但是原来slice不会变化。
</details>

# 4、go defer 多个defer的顺序，defer在什么时机会修改返回值？
<details>
  <summary> 查看/隐藏</summary>
  defer的执行顺序是后进先出，但是在函数返回时，defer的执行效果“先进先出”，所以defer修改返回值时，会在函数返回前修改。
</details>

```go
package main

import (
	"fmt"
)

func example() (result int) {
	defer func() {
		result += 10 // 第一个 defer，修改返回值
		fmt.Println("After first defer, result:", result)
	}()

	defer func() {
		result += 5 // 第二个 defer，修改返回值
		fmt.Println("After second defer, result:", result)
	}()

	result = 0 // 初始返回值
	fmt.Println("Initial result:", result)
	return // 返回时，defer 语句按定义的顺序执行
}

func main() {
	finalResult := example()
	fmt.Println("Final result:", finalResult) // 输出最终的返回值
}

//输出：
Initial result: 0
After second defer, result: 5
After first defer, result: 15
Final result: 15
```

# 5、go 中单引号，双引号，反引号的区别
<details>
  <summary> 查看/隐藏</summary>
  单引号：单引号包裹的字符串，会原样输出，不会转义，适用于一些特殊字符，比如：' '、'\t'、'\n'、'\r'、'\''、'\"'、'\\'等。
  双引号：双引号包裹的字符串，会转义特殊字符，适用于一般字符串。
  反引号：反引号包裹的字符串，会执行系统命令，并将命令的输出作为字符串输出。
</details>

# 6、go 的函数与方法及方法接受者的区别
<details>
  <summary> 查看/隐藏</summary>
  函数：独立，入参出参，实现一些功能，通用函数，没有接受者。
  方法：方法是与某个类型绑定的函数，必须通过该类型的实例调用，或者通过其指针接收者调用。可以修改该类型的对象的状态，提供该类型的功能。
  方法接受者：方法接受者是调用方法的对象，可以是值类型或指针类型。

</details>

# 7、go defer 底层数据结构和一些特性？
<details>
  <summary> 查看/隐藏</summary>
  defer 底层数据结构是一个栈，先进后出，defer 语句在函数返回时，会按定义的顺序执行。
  defer 特性：
  1. 延迟函数调用：defer 语句会将函数调用推迟到函数返回时执行。
  2. 延迟语句块执行：defer 语句可以延迟执行语句块，即使函数调用失败也会执行。
  3. 延迟函数返回值：defer 语句可以延迟函数返回值，并在函数返回时修改。
  4. 延迟panic：defer 语句可以延迟 panic，并在 panic 时恢复正常执行。
  5. 延迟 recover：defer 语句可以延迟 recover，并在 recover 时恢复正常执行。
</details>

```go
package main

import (
	"fmt"
)

func riskyFunction() {
	defer func() {
		if r := recover(); r != nil {
			fmt.Println("Recovered from panic:", r)
		}
	}()

	fmt.Println("About to panic!")
	panic("Something went wrong!")
}

func main() {
	riskyFunction()
	fmt.Println("After riskyFunction call")
}


输出：
About to panic!
Recovered from panic: Something went wrong!
After riskyFunction call

```
